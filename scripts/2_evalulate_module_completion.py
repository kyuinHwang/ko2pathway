import os,sys,glob,random,re,argparse
from collections import Counter

def isOver(value,threshold1=0,threshold2=0):
    if value > threshold1: return "C"
    elif value > threshold2: return "H"
    else: return "N"


## ModuleID      StepIDX    StepDef   SAG1 SAG2 SAG3 ... ModuleDefinition
## M00001	1	(K00844+K12407+K00845+K00886+K08074+K00918)	F	F	F ... Description
def main():
    parser = argparse.ArgumentParser(description="Evaluate module completeness based on step coverage result.")
    parser.add_argument("-i", "--input",required=True, help="Input step coverage file generated by M1_trackSteps.py")
    parser.add_argument("-o", "--output",required=True,help="Output file summarizing module completeness per genome (Complete:Half:Not)")
    parser.add_argument("--debug", action="store_true", help="Enable debug mode")

    args = parser.parse_args()

    print(f"Reading step coverage from: {args.input}")
    print(f"Saving module completeness summary to: {args.output}")

    inputFN, outFN = args.input, args.output
    debug=args.debug
    iFP = open(inputFN,'r')
    columns = iFP.readline().split('\t')
    sagIDs = columns[3:-1]
    moduleStepD, moduleDefD, sagModuleD = {}, {}, {sagID:{} for sagID in sagIDs}
    for line in iFP:
        moduleID, stepIDX, stepDef, *values, moduleDef = line.strip().split('\t')
        stepIDX = int(stepIDX)
        moduleStepD.setdefault(moduleID,[])
        moduleDefD.setdefault(moduleID,moduleDef)
        moduleStepD[moduleID].append(stepDef)

        for sagID, presenceStep in zip(sagIDs, values):
            sagModuleD[sagID].setdefault(moduleID,[])
            if presenceStep == "T": sagModuleD[sagID][moduleID].append(stepIDX)

    ## First one is for complete, laters are for halfs
    modulecutoffD = {"M00001":[((3,9), 7), ((3,), 5), ((9,), 5),],
                     "M00003":[((1,7), 5), ((1,), 4), ((7,) ,4)],
                     "M00009":[((3,4), 5), ((3,), 4), ((4,), 4)],
                     "M00012":[((3,4), 4), ((3,), 3), ((4,), 3)],
                     "M00309":[((2,3), 0),],
                     "M00087":[((2,), 3),((2,),2)]}

    wFP = open(outFN,'w')
    wFP.write('\t'.join(["Rank","moduleID","moduleDef/stepID","#steps/stepDef"]+sagIDs)+'\n')

    for moduleID, cutoffInfoL in sorted(modulecutoffD.items()):
        compCutoff, *halfCutoffL = cutoffInfoL

        ## cutoff for complete
        keySteps, minSteps = compCutoff
        decisionD = {}
        for sagID in sagIDs:
            includeSteps = sagModuleD[sagID][moduleID]
            if len(set(keySteps) - set(includeSteps)) == 0 and len(includeSteps) >= minSteps: decisionD[sagID] = "Y" #"C"
            else:
                for keySteps_h, minSteps_h in halfCutoffL:
                    if len(set(keySteps_h) - set(includeSteps)) == 0 and len(includeSteps) >= minSteps_h: decisionD[sagID] = "Y" #'H'
            if sagID not in decisionD: decisionD[sagID] = "N"
        wList = ["1.Module",moduleID,moduleDefD[moduleID],len(moduleStepD[moduleID])] + [decisionD[sagID] for sagID in sagIDs]        
        wFP.write("\t".join(map(str,wList)) + '\n')
        if debug == True:
            wList = ["2.#Steps",moduleID,moduleDefD[moduleID],len(moduleStepD[moduleID])] + [len(sagModuleD[sagID][moduleID]) for sagID in sagIDs]
            wFP.write("\t".join(map(str,wList)) + '\n')
            for stepIDX in keySteps:
                stepDef = moduleStepD[moduleID][stepIDX-1]
                wList = ["2.KeyStep",moduleID,f"{moduleID}_{stepIDX}",stepDef] + [sagModuleD[sagID][moduleID].count(stepIDX)>0 for sagID in sagIDs] ## find return -1 when not detected 
                wFP.write("\t".join(map(str,wList)) + '\n')            
    wFP.close()




if __name__ == "__main__": main()
